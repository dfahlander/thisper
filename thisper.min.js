export const InjectedTypeSymbol = Symbol();
export const MiddlewareForSymbol = Symbol();
class CallableThis {}
Symbol.hasInstance;
export const Contextual = function (config) {
  const ContextualWithConfig = function () {};
  ContextualWithConfig.deps = config.deps && Object.freeze(config.deps);
  ContextualWithConfig.prototype = Object.create(Contextual.prototype);
  ContextualWithConfig.construct =
    "construct" in config
      ? config.construct
      : "stateful" in config && config.stateful
      ? function (di, args) {
          const obj = Reflect.construct(this, args);
          const redirectHandler = {
            apply: (inject, thiz, args) => Reflect.apply(inject, di, args),
            get: (_, prop) => obj[prop],
            set: (_, prop, value) => Reflect.set(obj, prop, value),
          };
          for (const [prop, fn] of Object.entries(Reflect)) {
            if (!(prop in redirectHandler)) {
              redirectHandler[prop] = (_, ...args) =>
                Reflect[prop](obj, ...args);
            }
          }
          return new Proxy(di.inject, redirectHandler);
        }
      : Contextual.construct;
  return ContextualWithConfig;
};
Contextual.construct = function (di) {
  const f = di.inject.bind(di);
  Object.setPrototypeOf(f, this.prototype);
  f.constructor = this;
  return f;
};
function getBackingInstance(i) {
  const backer = i[MiddlewareForSymbol];
  return backer ? getBackingInstance(backer) : i;
}
const depInjectCache = new WeakMap();
function findDependentInjection(di, Class) {
  const { deps } = Class;
  let i = 0,
    l = deps.length;
  let x = depInjectCache.get(Class);
  const depInstances = deps.map((dep) => getBackingInstance(di.inject(dep)));
  while (x && x instanceof WeakMap) {
    if (i >= l) throw Error("INTERNAL: Deps inconsistency!");
    x = x.get(depInstances[i++]);
  }
  return [x, depInstances];
}
function storeDependentInjection(C, instance, depInstances) {
  let wm1 = depInjectCache;
  let key = C;
  for (let i = 0, l = depInstances.length; i < l; ++i) {
    let wm2 = wm1.get(key);
    if (!wm2 || !(wm2 instanceof WeakMap)) {
      wm1.set(key, (wm2 = new WeakMap()));
    }
    key = depInstances[i];
    wm1 = wm2;
  }
  wm1.set(key, instance);
}
let circProtect;
const defaultDI = {
  injectCache: new WeakMap(),
  map(Class) {
    return Class;
  },
  proxyInstance(i) {
    return i;
  },
  create(Class, ...args) {
    Class = this.map(Class);
    if ("construct" in Class)
      return this.proxyInstance(Class.construct(this, args));
    return this.proxyInstance(new Class(...args));
  },
  inject(Class) {
    if (!Class) throw TypeError(`Cannot inject non-class ${Class}`);
    let instance = this.injectCache.get(Class);
    if (!instance) {
      instance = this._inject(Class);
      this.injectCache.set(Class, instance);
    }
    return instance;
  },
  _inject(GivenClass) {
    const Class = GivenClass.prototype[InjectedTypeSymbol] ?? GivenClass;
    if (Class.deps) {
      if (circProtect.has(Class)) throw Error(`Circular deps in ${Class.name}`);
      circProtect.add(Class);
      try {
        let [instance, depInstances] = findDependentInjection(this, Class);
        if (!instance) {
          instance = this.create(Class);
          storeDependentInjection(Class, instance, depInstances);
        }
        return instance;
      } finally {
        circProtect.delete(Class);
      }
    }
    return this.create(Class);
  },
  run(fn) {
    if (typeof fn !== "function" || !(fn instanceof Function))
      throw new TypeError("Argument to DI.run() must be a function.");
    if (!fn.prototype)
      throw new TypeError("Argument to DI.run() must not be arrow function.");
    return fn.apply(this.inject.bind(this));
  },
  DI(...providers) {
    return providers.reduce((di, provider) => {
      if (!provider) throw new TypeError("Given provider is falsy");
      if (provider instanceof Function) {
        if (Object.getPrototypeOf(provider) !== Function.prototype) {
          return {
            ...di,
            injectCache: new WeakMap(),
            map(C) {
              return di.map(provider.prototype instanceof C ? provider : C);
            },
          };
        } else {
          return provider(di);
        }
      } else if (
        typeof provider === "object" ||
        typeof provider === "function"
      ) {
        return {
          ...di,
          injectCache: new WeakMap(),
          _inject(Class) {
            return provider instanceof Class
              ? this.proxyInstance(provider)
              : di._inject.call(this, Class);
          },
        };
      } else {
        throw new TypeError("provider is neither class, function or object");
      }
    }, this);
  },
};
export function DI(...providers) {
  return defaultDI.DI(...providers);
}
export function middleware(Type, createMiddleware) {
  return (di) => ({
    ...di,
    mapInstance(i) {
      const rv = Object.create(
        i,
        Object.getOwnPropertyDescriptors(createMiddleware(i))
      );
      rv[MiddlewareForSymbol] = i;
      return rv;
    },
  });
}
